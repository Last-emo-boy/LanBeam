<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LanBeam æµ‹è¯•é¡µé¢</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }
        .test-result {
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .warning {
            background: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        button {
            background: #1976d2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #1565c0;
        }
        .log {
            background: #000;
            color: #0f0;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h1>ğŸ§ª LanBeam æµ‹è¯•é¡µé¢</h1>
    
    <div class="test-section">
        <h2>æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•</h2>
        <button onclick="testBrowserSupport()">è¿è¡Œå…¼å®¹æ€§æµ‹è¯•</button>
        <div id="browser-results"></div>
    </div>
    
    <div class="test-section">
        <h2>WebRTC è¿æ¥æµ‹è¯•</h2>
        <button onclick="testWebRTCConnection()">æµ‹è¯• WebRTC</button>
        <button onclick="testLocalNetwork()">è·å–æœ¬åœ°ç½‘ç»œä¿¡æ¯</button>
        <div id="webrtc-results"></div>
    </div>
    
    <div class="test-section">
        <h2>åŠ å¯†åŠŸèƒ½æµ‹è¯•</h2>
        <button onclick="testCrypto()">æµ‹è¯•åŠ å¯†åŠŸèƒ½</button>
        <div id="crypto-results"></div>
    </div>
    
    <div class="test-section">
        <h2>QR ç åŠŸèƒ½æµ‹è¯•</h2>
        <button onclick="testQRGeneration()">ç”Ÿæˆæµ‹è¯• QR ç </button>
        <button onclick="testCameraAccess()">æµ‹è¯•æ‘„åƒå¤´è®¿é—®</button>
        <div id="qr-results"></div>
    </div>
    
    <div class="test-section">
        <h2>æ–‡ä»¶å¤„ç†æµ‹è¯•</h2>
        <input type="file" id="test-file" multiple>
        <button onclick="testFileProcessing()">æµ‹è¯•æ–‡ä»¶å¤„ç†</button>
        <div id="file-results"></div>
    </div>
    
    <div class="test-section">
        <h2>æ€§èƒ½æµ‹è¯•</h2>
        <button onclick="testPerformance()">è¿è¡Œæ€§èƒ½æµ‹è¯•</button>
        <div id="performance-results"></div>
    </div>
    
    <div class="test-section">
        <h2>è°ƒè¯•æ—¥å¿—</h2>
        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        <div id="debug-log" class="log"></div>
    </div>

    <script type="module">
        // å¯¼å…¥æ ¸å¿ƒæ¨¡å—è¿›è¡Œæµ‹è¯•
        import { LanBeamConnection, ConnectionUtils } from './core/connection.js';
        import { FileTransferEngine, TransferUtils } from './core/transfer.js';
        import { LanBeamCrypto, CryptoUtils } from './core/crypto.js';
        import { QRManualAdapter, QRUtils } from './adapters/qr-manual.js';

        let logElement = document.getElementById('debug-log');

        function log(message, type = 'info') {
            const timestamp = new Date().toISOString();
            const prefix = type === 'error' ? 'âŒ' : type === 'success' ? 'âœ…' : type === 'warning' ? 'âš ï¸' : 'â„¹ï¸';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
            console.log(`[Test] ${message}`);
        }

        window.clearLog = () => {
            logElement.textContent = '';
        };

        // æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•
        window.testBrowserSupport = async () => {
            log('å¼€å§‹æµè§ˆå™¨å…¼å®¹æ€§æµ‹è¯•...');
            const resultsElement = document.getElementById('browser-results');
            resultsElement.innerHTML = '';
            
            const tests = [
                {
                    name: 'WebRTC æ”¯æŒ',
                    test: () => ConnectionUtils.isSupported(),
                },
                {
                    name: 'Web Crypto API',
                    test: () => CryptoUtils.isSupported(),
                },
                {
                    name: 'File API',
                    test: () => typeof File !== 'undefined' && typeof FileReader !== 'undefined',
                },
                {
                    name: 'QR ç åº“',
                    test: () => typeof QRCode !== 'undefined',
                },
                {
                    name: 'QR æ‰«æå™¨',
                    test: () => typeof QrScanner !== 'undefined',
                },
                {
                    name: 'æ‘„åƒå¤´ API',
                    test: () => navigator.mediaDevices && navigator.mediaDevices.getUserMedia,
                },
                {
                    name: 'å‰ªè´´æ¿ API',
                    test: () => navigator.clipboard,
                },
                {
                    name: 'Service Worker',
                    test: () => 'serviceWorker' in navigator,
                },
                {
                    name: 'File System Access API',
                    test: () => 'showSaveFilePicker' in window,
                }
            ];

            for (const test of tests) {
                try {
                    const result = test.test();
                    const className = result ? 'success' : 'warning';
                    const status = result ? 'âœ… æ”¯æŒ' : 'âš ï¸ ä¸æ”¯æŒ';
                    
                    resultsElement.innerHTML += `
                        <div class="test-result ${className}">
                            <strong>${test.name}:</strong> ${status}
                        </div>
                    `;
                    
                    log(`${test.name}: ${result ? 'æ”¯æŒ' : 'ä¸æ”¯æŒ'}`, result ? 'success' : 'warning');
                } catch (error) {
                    resultsElement.innerHTML += `
                        <div class="test-result error">
                            <strong>${test.name}:</strong> âŒ é”™è¯¯ - ${error.message}
                        </div>
                    `;
                    log(`${test.name} æµ‹è¯•å‡ºé”™: ${error.message}`, 'error');
                }
            }
        };

        // WebRTC è¿æ¥æµ‹è¯•
        window.testWebRTCConnection = async () => {
            log('æµ‹è¯• WebRTC è¿æ¥...');
            const resultsElement = document.getElementById('webrtc-results');
            
            try {
                const connection = new LanBeamConnection({ debug: true });
                
                connection.addEventListener('stateChange', (e) => {
                    log(`è¿æ¥çŠ¶æ€å˜åŒ–: ${e.detail.newState}`);
                });

                const offer = await connection.createOffer();
                log(`æˆåŠŸåˆ›å»º Offer (${offer.length} å­—ç¬¦)`, 'success');
                
                resultsElement.innerHTML = `
                    <div class="test-result success">
                        âœ… WebRTC è¿æ¥æµ‹è¯•é€šè¿‡<br>
                        SDP Offer é•¿åº¦: ${offer.length} å­—ç¬¦
                    </div>
                `;
                
                connection.close();
            } catch (error) {
                log(`WebRTC æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                resultsElement.innerHTML = `
                    <div class="test-result error">
                        âŒ WebRTC æµ‹è¯•å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        };

        // æœ¬åœ°ç½‘ç»œä¿¡æ¯
        window.testLocalNetwork = async () => {
            log('è·å–æœ¬åœ°ç½‘ç»œä¿¡æ¯...');
            const resultsElement = document.getElementById('webrtc-results');
            
            try {
                const networkInfo = await ConnectionUtils.getLocalNetworkInfo();
                log(`æœ¬åœ° IP: ${networkInfo.localIP || 'æ— æ³•è·å–'}`, 'info');
                
                const deviceFingerprint = await ConnectionUtils.generateDeviceFingerprint();
                log(`è®¾å¤‡æŒ‡çº¹: ${deviceFingerprint.id}`, 'info');
                
                resultsElement.innerHTML += `
                    <div class="test-result success">
                        âœ… ç½‘ç»œä¿¡æ¯è·å–æˆåŠŸ<br>
                        æœ¬åœ° IP: ${networkInfo.localIP || 'æ— æ³•è·å–'}<br>
                        è®¾å¤‡ ID: ${deviceFingerprint.id}
                    </div>
                `;
            } catch (error) {
                log(`è·å–ç½‘ç»œä¿¡æ¯å¤±è´¥: ${error.message}`, 'error');
                resultsElement.innerHTML += `
                    <div class="test-result error">
                        âŒ ç½‘ç»œä¿¡æ¯è·å–å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        };

        // åŠ å¯†åŠŸèƒ½æµ‹è¯•
        window.testCrypto = async () => {
            log('æµ‹è¯•åŠ å¯†åŠŸèƒ½...');
            const resultsElement = document.getElementById('crypto-results');
            
            try {
                const crypto = new LanBeamCrypto();
                
                // æµ‹è¯• SHA-256
                const testData = new TextEncoder().encode('Hello, LanBeam!');
                const hash = await crypto.calculateSHA256(testData);
                log(`SHA-256 å“ˆå¸Œ: ${hash}`, 'info');
                
                // æµ‹è¯• CRC32
                const crc = await crypto.calculateCRC32(testData);
                log(`CRC32 æ ¡éªŒå’Œ: ${crc}`, 'info');
                
                // æµ‹è¯•éšæœºæ•°ç”Ÿæˆ
                const randomKey = crypto.generateSessionKey(32);
                log(`ç”Ÿæˆéšæœºå¯†é’¥: ${crypto.bytesToHex(randomKey)}`, 'info');
                
                resultsElement.innerHTML = `
                    <div class="test-result success">
                        âœ… åŠ å¯†åŠŸèƒ½æµ‹è¯•é€šè¿‡<br>
                        SHA-256: ${hash.substring(0, 16)}...<br>
                        CRC32: ${crc}<br>
                        éšæœºå¯†é’¥é•¿åº¦: ${randomKey.length} å­—èŠ‚
                    </div>
                `;
                
                log('åŠ å¯†åŠŸèƒ½æµ‹è¯•é€šè¿‡', 'success');
            } catch (error) {
                log(`åŠ å¯†æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                resultsElement.innerHTML = `
                    <div class="test-result error">
                        âŒ åŠ å¯†æµ‹è¯•å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        };

        // QR ç æµ‹è¯•
        window.testQRGeneration = async () => {
            log('æµ‹è¯• QR ç ç”Ÿæˆ...');
            const resultsElement = document.getElementById('qr-results');
            
            try {
                const adapter = new QRManualAdapter({ debug: true });
                const testSdp = 'v=0\no=- 123456 2 IN IP4 127.0.0.1\ns=-\nt=0 0\na=group:BUNDLE 0\nm=application 9 UDP/DTLS/SCTP webrtc-datachannel';
                
                const qrResult = await adapter.generateOfferQR(testSdp);
                log('QR ç ç”ŸæˆæˆåŠŸ', 'success');
                
                resultsElement.innerHTML = `
                    <div class="test-result success">
                        âœ… QR ç ç”Ÿæˆæµ‹è¯•é€šè¿‡<br>
                        æ•°æ®é•¿åº¦: ${qrResult.rawData.length} å­—ç¬¦<br>
                        <img src="${qrResult.dataURL}" alt="æµ‹è¯• QR ç " style="max-width: 200px; margin-top: 10px;">
                    </div>
                `;
            } catch (error) {
                log(`QR ç ç”Ÿæˆå¤±è´¥: ${error.message}`, 'error');
                resultsElement.innerHTML = `
                    <div class="test-result error">
                        âŒ QR ç ç”Ÿæˆå¤±è´¥: ${error.message}
                    </div>
                `;
            }
        };

        // æ‘„åƒå¤´æµ‹è¯•
        window.testCameraAccess = async () => {
            log('æµ‹è¯•æ‘„åƒå¤´è®¿é—®...');
            const resultsElement = document.getElementById('qr-results');
            
            try {
                const hasCamera = await QRUtils.isCameraSupported();
                log(`æ‘„åƒå¤´æ”¯æŒ: ${hasCamera}`, hasCamera ? 'success' : 'warning');
                
                if (hasCamera) {
                    const permission = await QRUtils.requestCameraPermission();
                    log(`æ‘„åƒå¤´æƒé™: ${permission}`, permission ? 'success' : 'warning');
                    
                    resultsElement.innerHTML += `
                        <div class="test-result ${permission ? 'success' : 'warning'}">
                            ${permission ? 'âœ…' : 'âš ï¸'} æ‘„åƒå¤´è®¿é—®${permission ? 'æˆåŠŸ' : 'è¢«æ‹’ç»'}
                        </div>
                    `;
                } else {
                    resultsElement.innerHTML += `
                        <div class="test-result warning">
                            âš ï¸ æœªæ£€æµ‹åˆ°æ‘„åƒå¤´è®¾å¤‡
                        </div>
                    `;
                }
            } catch (error) {
                log(`æ‘„åƒå¤´æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                resultsElement.innerHTML += `
                    <div class="test-result error">
                        âŒ æ‘„åƒå¤´æµ‹è¯•å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        };

        // æ–‡ä»¶å¤„ç†æµ‹è¯•
        window.testFileProcessing = async () => {
            log('æµ‹è¯•æ–‡ä»¶å¤„ç†...');
            const resultsElement = document.getElementById('file-results');
            const fileInput = document.getElementById('test-file');
            
            if (fileInput.files.length === 0) {
                resultsElement.innerHTML = `
                    <div class="test-result warning">
                        âš ï¸ è¯·å…ˆé€‰æ‹©æ–‡ä»¶
                    </div>
                `;
                return;
            }
            
            try {
                const files = Array.from(fileInput.files);
                log(`é€‰æ‹©äº† ${files.length} ä¸ªæ–‡ä»¶`, 'info');
                
                const crypto = new LanBeamCrypto();
                let totalSize = 0;
                
                for (const file of files) {
                    totalSize += file.size;
                    const hash = await crypto.calculateSHA256(file);
                    const icon = TransferUtils.getFileIcon(file.name, file.type);
                    
                    log(`æ–‡ä»¶: ${file.name}, å¤§å°: ${TransferUtils.formatFileSize(file.size)}, å“ˆå¸Œ: ${hash.substring(0, 16)}...`, 'info');
                }
                
                resultsElement.innerHTML = `
                    <div class="test-result success">
                        âœ… æ–‡ä»¶å¤„ç†æµ‹è¯•é€šè¿‡<br>
                        æ–‡ä»¶æ•°é‡: ${files.length}<br>
                        æ€»å¤§å°: ${TransferUtils.formatFileSize(totalSize)}<br>
                        è¯¦æƒ…è¯·æŸ¥çœ‹è°ƒè¯•æ—¥å¿—
                    </div>
                `;
                
                log('æ–‡ä»¶å¤„ç†æµ‹è¯•å®Œæˆ', 'success');
            } catch (error) {
                log(`æ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}`, 'error');
                resultsElement.innerHTML = `
                    <div class="test-result error">
                        âŒ æ–‡ä»¶å¤„ç†å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        };

        // æ€§èƒ½æµ‹è¯•
        window.testPerformance = async () => {
            log('å¼€å§‹æ€§èƒ½æµ‹è¯•...');
            const resultsElement = document.getElementById('performance-results');
            
            try {
                // æµ‹è¯•åŠ å¯†æ€§èƒ½
                const startTime = performance.now();
                const crypto = new LanBeamCrypto();
                
                const testData = new Uint8Array(1024 * 1024); // 1MB æµ‹è¯•æ•°æ®
                crypto.getRandomValues(testData);
                
                const hashStart = performance.now();
                const hash = await crypto.calculateSHA256(testData);
                const hashTime = performance.now() - hashStart;
                
                const crcStart = performance.now();
                const crc = await crypto.calculateCRC32(testData);
                const crcTime = performance.now() - crcStart;
                
                const totalTime = performance.now() - startTime;
                
                // è®¡ç®—ååé‡
                const hashThroughput = (testData.length / hashTime * 1000) / (1024 * 1024); // MB/s
                const crcThroughput = (testData.length / crcTime * 1000) / (1024 * 1024); // MB/s
                
                log(`SHA-256 æ€§èƒ½: ${hashTime.toFixed(2)}ms, ${hashThroughput.toFixed(2)} MB/s`, 'info');
                log(`CRC32 æ€§èƒ½: ${crcTime.toFixed(2)}ms, ${crcThroughput.toFixed(2)} MB/s`, 'info');
                
                resultsElement.innerHTML = `
                    <div class="test-result success">
                        âœ… æ€§èƒ½æµ‹è¯•å®Œæˆ (1MB æ•°æ®)<br>
                        SHA-256: ${hashTime.toFixed(2)}ms (${hashThroughput.toFixed(2)} MB/s)<br>
                        CRC32: ${crcTime.toFixed(2)}ms (${crcThroughput.toFixed(2)} MB/s)<br>
                        æ€»è€—æ—¶: ${totalTime.toFixed(2)}ms
                    </div>
                `;
                
                log('æ€§èƒ½æµ‹è¯•å®Œæˆ', 'success');
            } catch (error) {
                log(`æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                resultsElement.innerHTML = `
                    <div class="test-result error">
                        âŒ æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}
                    </div>
                `;
            }
        };

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨è¿è¡Œå…¼å®¹æ€§æµ‹è¯•
        document.addEventListener('DOMContentLoaded', () => {
            log('æµ‹è¯•é¡µé¢å·²åŠ è½½');
            setTimeout(() => {
                testBrowserSupport();
            }, 500);
        });
    </script>
</body>
</html>
